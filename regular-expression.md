# 正则表达式（From _Mastering Regular Expressions_）
## 行的开始和结束
^ $匹配的是一个位置，而不是具体的文本
## 字符组[...]
### 匹配若干字符之一
* gr[ea]y 首先匹配g，接下来是r，接下来是e或者a,然后是y
* H[123456] H[1-6] [0123456abcdef] [0-9a-fA-F] [a-fA-F0-9] [0-9A-Z_!.?]
* “-”在字符组开头是普通字符，而不是元字符（表示范围）
* 关于元字符的规定，在字符组内部和外部是不同的。
### 排除型字符组
* ^在字符组内部（而且必须是在紧接在字符组的第一个方括号之后）表示一个元字符：排除
* [^1-6] 匹配1到6以外的任何字符
* 一个字符组，即使是排除型字符组，也需要匹配一个字符，注意大小写
## 用点号匹配任意字符
* 03.19.76（元字符 匹配任意字符）  03[-./]19[-./]76 ([.-/]这里的-是元字符，[-./]普通字符，意义不同)
> * NOTE：写正则表达式时，我们需要在对欲检索文本的了解程度与检索准确性之间求得平衡。 了解目标文本是非常重要的。

## 多选结构 Alternation
### 匹配任意子表达式
* 一个字符组只能匹配目标文本中的单个字符，而多选结构自身都可能是完整的正则表达式，都可以匹配任意长度的文本
* ( )的使用
#### 忽略大小写
* egrep -i
### 单词分界符
* 如果egrep支持‘元字符序列’ ‘\<’和‘\>’就可以使用它们来匹配单词分界的位置，单词的开头和结束，准确地说是“字母数字符号的开始和结束”。
* 可以把它们想象为单词版本的^ $
#### 可选项元素 ？
* colou?r   ?只作用于之前紧邻的元素，无论u是否出现，匹配都是成功的。
* July? fourth|4(th)?
### 其他量词：重复出现
* “+ * ？”元字符统称为量词quantifiers 因为它们限定了所作用元素的匹配次数。
* 都是作用于之前紧邻的元素。
* “+” 至少匹配一次，匹配一个或多个，在无法进行一次匹配时，会报告匹配失败
* “？”最多匹配一次，匹配一个或零个，总是匹配成功
* “*” 匹配任意多个字符，匹配零个 一个或多个，总是匹配成功
### 规定重现次数的范围：区间
* 某些egrep版本可以自定义重复次数区间{min,max}， “区间量词”interval quantifier
* [a-zA-Z]{1,5}
### 括号及反向引用
* 某些egrep支持 反向引用backreference
* \<the the\>  \<(the) \1\>, \1为特殊的元字符序列。
> * NOTE: 括号能够记忆其中的子表达式匹配的文本，不论这些文本时什么，元字符序列\1都能记住它们。括号能够记忆其中的子表达式匹配的文本，不论这些文本时什么，元字符序列\1都能记住它们。
* \<([A-Za-z]+) +\1\>
#神奇的转义
* ‘\’ 转义符，需要匹配的某个字符本身是元字符，则使用转义符
* \. 转义的点号，这个方法适用于所有元字符，不过在字符组内部无效。
* \([a-z]+\) 匹配括号内的单词
> * NOTE:大多数程序设计语言和工具都支持字符组内部的转义，但大多数的egrep不支持，它们会把反斜线‘\’当作字符组内部列出的普通字符。
### 语言的差异
* 每一种支持正则表达式的语言都提供了自己的‘改进’，多年的变化造就了数目众多的正则表达式“流派”flavor。

### 更多的例子
* 在任何语言中，经验都是非常重要的。
* 变量名，'[a-zA-Z_][a-zA-Z_0-9]*'  '[a-zA-Z_][a-zA-Z_0-9]{0,31}'
* 引号内的字符串，'"[^"]*"'
* 美元金额（可能包含小数），'\$[0-9]+(\.[0-9][0-9])?'
* 常见的HTTP/HTML URL，'\<http://[-a-z0-9_.:]+/[-a-z0-9_:@&?=+,.!/~*%$]*\.html?\>'，'\<http://[^ ]*\.html?\>'
* 表示时刻的文字，例如‘9:17 am’ 或者 ‘12:30 pm’， '(1[012]|0?[1-9]):[0-5][0-9] (am|pm)'
* 24小时制，'(1[0-9]|0?[0-9]|2[0-3]):[0-5][0-9]'，'([01]?[0-9]|2[0-3]):[0-5][0-9]'，'([01]?[4-9]|[012]?[0-3]):[0-5][0-9]'
### 子表达式
### 字符